'use strict';

exports.__esModule = true;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _LineFragment = require('../models/LineFragment');

var _LineFragment2 = _interopRequireDefault(_LineFragment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ALIGNMENT_FACTORS = {
  left: 0,
  center: 0.5,
  right: 1,
  justify: 0
};

/**
 * A Typesetter performs glyph line layout, including line breaking,
 * hyphenation, justification, truncation, hanging punctuation,
 * and text decoration. It uses several underlying objects to perform
 * these tasks, which could be overridden in order to customize the
 * typesetter's behavior.
 */

var Typesetter = function () {
  function Typesetter() {
    var engines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Typesetter);

    this.lineBreaker = engines.lineBreaker;
    this.lineFragmentGenerator = engines.lineFragmentGenerator;
    this.justificationEngine = engines.justificationEngine;
    this.truncationEngine = engines.truncationEngine;
    this.decorationEngine = engines.decorationEngine;
    this.tabEngine = engines.tabEngine;
  }

  Typesetter.prototype.layoutLineFragments = function layoutLineFragments(start, lineRect, glyphString, container, paragraphStyle, stringOffset) {
    var lineString = glyphString.slice(start, glyphString.length);

    // Guess the line height using the full line before intersecting with the container.
    lineRect.height = lineString.slice(0, lineString.glyphIndexAtOffset(lineRect.width)).height;

    // Generate line fragment rectangles by intersecting with the container.
    var fragmentRects = this.lineFragmentGenerator.generateFragments(lineRect, container);

    if (fragmentRects.length === 0) return [];

    var pos = 0;
    var lineFragments = [];
    var lineHeight = paragraphStyle.lineHeight;

    for (var _iterator = fragmentRects, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var fragmentRect = _ref;

      var line = lineString.slice(pos, lineString.length);

      if (this.tabEngine) {
        this.tabEngine.processLineFragment(line, container);
      }

      var bk = this.lineBreaker.suggestLineBreak(line, fragmentRect.width, paragraphStyle);

      if (bk) {
        bk.position += pos;

        var lineFragment = new _LineFragment2.default(fragmentRect, lineString.slice(pos, bk.position));

        lineFragment.stringStart = stringOffset + glyphString.stringIndexForGlyphIndex(lineFragment.start);
        lineFragment.stringEnd = stringOffset + glyphString.stringIndexForGlyphIndex(lineFragment.end);

        lineFragments.push(lineFragment);
        lineHeight = Math.max(lineHeight, lineFragment.height);

        pos = bk.position;
        if (pos >= lineString.length) {
          break;
        }
      }
    }

    // Update the fragments on this line with the computed line height
    if (lineHeight !== 0) lineRect.height = lineHeight;

    for (var _iterator2 = lineFragments, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var fragment = _ref2;

      fragment.rect.height = lineHeight;
    }

    return lineFragments;
  };

  Typesetter.prototype.finalizeLineFragment = function finalizeLineFragment(lineFragment, paragraphStyle, isLastFragment, isTruncated) {
    var align = isLastFragment && !isTruncated ? paragraphStyle.alignLastLine : paragraphStyle.align;

    if (isLastFragment && isTruncated && paragraphStyle.truncationMode) {
      this.truncationEngine.truncate(lineFragment, paragraphStyle.truncationMode);
    }

    this.adjustLineFragmentRectangle(lineFragment, paragraphStyle, align);

    if (align === 'justify' || lineFragment.advanceWidth > lineFragment.rect.width) {
      this.justificationEngine.justify(lineFragment, {
        factor: paragraphStyle.justificationFactor
      });
    }

    this.decorationEngine.createDecorationLines(lineFragment);
  };

  Typesetter.prototype.adjustLineFragmentRectangle = function adjustLineFragmentRectangle(lineFragment, paragraphStyle, align) {
    var start = 0;
    var end = lineFragment.length;

    // Ignore whitespace at the start and end of a line for alignment
    while (lineFragment.isWhiteSpace(start)) {
      lineFragment.overflowLeft += lineFragment.getGlyphWidth(start++);
    }

    while (lineFragment.isWhiteSpace(end - 1)) {
      lineFragment.overflowRight += lineFragment.getGlyphWidth(--end);
    }

    // Adjust line rect for hanging punctuation
    if (paragraphStyle.hangingPunctuation) {
      if (align === 'left' || align === 'justify') {
        if (lineFragment.isHangingPunctuationStart(start)) {
          lineFragment.overflowLeft += lineFragment.getGlyphWidth(start++);
        }
      }

      if (align === 'right' || align === 'justify') {
        if (lineFragment.isHangingPunctuationEnd(end - 1)) {
          lineFragment.overflowRight += lineFragment.getGlyphWidth(--end);
        }
      }
    }

    lineFragment.rect.x -= lineFragment.overflowLeft;
    lineFragment.rect.width += lineFragment.overflowLeft + lineFragment.overflowRight;

    // Adjust line offset for alignment
    var remainingWidth = lineFragment.rect.width - lineFragment.advanceWidth;
    lineFragment.rect.x += remainingWidth * ALIGNMENT_FACTORS[align];
  };

  return Typesetter;
}();

exports.default = Typesetter;