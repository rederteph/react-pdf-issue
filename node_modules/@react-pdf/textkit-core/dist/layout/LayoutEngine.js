'use strict';

exports.__esModule = true;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _ParagraphStyle = require('../models/ParagraphStyle');

var _ParagraphStyle2 = _interopRequireDefault(_ParagraphStyle);

var _Rect = require('../geom/Rect');

var _Rect2 = _interopRequireDefault(_Rect);

var _Block = require('../models/Block');

var _Block2 = _interopRequireDefault(_Block);

var _GlyphGenerator = require('./GlyphGenerator');

var _GlyphGenerator2 = _interopRequireDefault(_GlyphGenerator);

var _Typesetter = require('./Typesetter');

var _Typesetter2 = _interopRequireDefault(_Typesetter);

var _injectEngines = require('./injectEngines');

var _injectEngines2 = _interopRequireDefault(_injectEngines);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 1. split into paragraphs
// 2. get bidi runs and paragraph direction
// 3. font substitution - map to resolved font runs
// 4. script itemization
// 5. font shaping - text to glyphs
// 6. line breaking
// 7. bidi reordering
// 8. justification

// 1. get a list of rectangles by intersecting path, line, and exclusion paths
// 2. perform line breaking to get acceptable break points for each fragment
// 3. ellipsize line if necessary
// 4. bidi reordering
// 5. justification

/**
 * A LayoutEngine is the main object that performs text layout.
 * It accepts an AttributedString and a list of Container objects
 * to layout text into, and uses several helper objects to perform
 * various layout tasks. These objects can be overridden to customize
 * layout behavior.
 */
var LayoutEngine = function () {
  function LayoutEngine(engines) {
    (0, _classCallCheck3.default)(this, LayoutEngine);

    var injectedEngines = (0, _injectEngines2.default)(engines);
    this.glyphGenerator = new _GlyphGenerator2.default(injectedEngines);
    this.typesetter = new _Typesetter2.default(injectedEngines);
  }

  LayoutEngine.prototype.layout = function layout(attributedString, containers) {
    var start = 0;

    for (var i = 0; i < containers.length && start < attributedString.length; i++) {
      var container = containers[i];
      var bbox = container.bbox,
          columns = container.columns,
          columnGap = container.columnGap;

      var isLastContainer = i === containers.length - 1;
      var columnWidth = (bbox.width - columnGap * (columns - 1)) / columns;
      var rect = new _Rect2.default(bbox.minX, bbox.minY, columnWidth, bbox.height);

      for (var j = 0; j < container.columns && start < attributedString.length; j++) {
        start = this.layoutColumn(attributedString, start, container, rect.copy(), isLastContainer);
        rect.x += columnWidth + container.columnGap;
      }
    }
  };

  LayoutEngine.prototype.layoutColumn = function layoutColumn(attributedString, start, container, rect, isLastContainer) {
    while (start < attributedString.length && rect.height > 0) {
      var next = attributedString.string.indexOf('\n', start);
      if (next === -1) next = attributedString.string.length;

      var paragraph = attributedString.slice(start, next);
      var block = this.layoutParagraph(paragraph, container, rect, start, isLastContainer);
      var paragraphHeight = block.bbox.height + block.style.paragraphSpacing;

      container.blocks.push(block);

      rect.y += paragraphHeight;
      rect.height -= paragraphHeight;
      start += paragraph.length + 1;

      // If entire paragraph did not fit, move on to the next column or container.
      if (start < next) break;
    }

    return start;
  };

  LayoutEngine.prototype.layoutParagraph = function layoutParagraph(attributedString, container, rect, stringOffset, isLastContainer) {
    var _this = this;

    var glyphString = this.glyphGenerator.generateGlyphs(attributedString);
    var paragraphStyle = new _ParagraphStyle2.default(attributedString.runs[0].attributes);
    var marginLeft = paragraphStyle.marginLeft,
        marginRight = paragraphStyle.marginRight,
        indent = paragraphStyle.indent,
        maxLines = paragraphStyle.maxLines,
        lineSpacing = paragraphStyle.lineSpacing;


    var lineRect = new _Rect2.default(rect.x + marginLeft + indent, rect.y, rect.width - marginLeft - indent - marginRight, glyphString.height);

    var pos = 0;
    var lines = 0;
    var firstLine = true;
    var fragments = [];

    while (lineRect.y < rect.maxY && pos < glyphString.length && lines < maxLines) {
      var lineFragments = this.typesetter.layoutLineFragments(pos, lineRect, glyphString, container, paragraphStyle, stringOffset);

      lineRect.y += lineRect.height + lineSpacing;

      if (lineFragments.length > 0) {
        fragments.push.apply(fragments, lineFragments);
        pos = lineFragments[lineFragments.length - 1].end;
        lines++;

        if (firstLine) {
          lineRect.x -= indent;
          lineRect.width += indent;
          firstLine = false;
        }
      }
    }

    // Add empty line fragment for empty glyph strings
    if (glyphString.length === 0) {
      var newLineFragment = this.typesetter.layoutLineFragments(pos, lineRect, glyphString, container, paragraphStyle);

      fragments.push.apply(fragments, newLineFragment);
    }

    var isTruncated = isLastContainer && pos < glyphString.length;
    fragments.forEach(function (fragment, i) {
      var isLastFragment = i === fragments.length - 1 && pos === glyphString.length;

      _this.typesetter.finalizeLineFragment(fragment, paragraphStyle, isLastFragment, isTruncated);
    });

    return new _Block2.default(fragments, paragraphStyle);
  };

  return LayoutEngine;
}();

exports.default = LayoutEngine;