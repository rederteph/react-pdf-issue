'use strict';

exports.__esModule = true;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _GlyphRun = require('../models/GlyphRun');

var _GlyphRun2 = _interopRequireDefault(_GlyphRun);

var _GlyphString = require('../models/GlyphString');

var _GlyphString2 = _interopRequireDefault(_GlyphString);

var _Run = require('../models/Run');

var _Run2 = _interopRequireDefault(_Run);

var _RunStyle = require('../models/RunStyle');

var _RunStyle2 = _interopRequireDefault(_RunStyle);

var _flattenRuns = require('./flattenRuns');

var _flattenRuns2 = _interopRequireDefault(_flattenRuns);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A GlyphGenerator is responsible for mapping characters in
 * an AttributedString to glyphs in a GlyphString. It resolves
 * style attributes such as the font and Unicode script and
 * directionality properties, and creates GlyphRuns using fontkit.
 */
var GlyphGenerator = function () {
  function GlyphGenerator() {
    var engines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, GlyphGenerator);

    this.resolvers = [engines.fontSubstitutionEngine, engines.scriptItemizer];
  }

  GlyphGenerator.prototype.generateGlyphs = function generateGlyphs(attributedString) {
    var _this = this;

    // Resolve runs
    var runs = this.resolveRuns(attributedString);

    // Generate glyphs
    var glyphIndex = 0;
    var glyphRuns = runs.map(function (run) {
      var str = attributedString.string.slice(run.start, run.end);
      var glyphRun = run.attributes.font.layout(str, run.attributes.features, run.attributes.script);
      var end = glyphIndex + glyphRun.glyphs.length;
      var glyphIndices = _this.resolveGlyphIndices(str, glyphRun.stringIndices);

      var res = new _GlyphRun2.default(glyphIndex, end, run.attributes, glyphRun.glyphs, glyphRun.positions, glyphRun.stringIndices, glyphIndices);

      _this.resolveAttachments(res);
      _this.resolveYOffset(res);

      glyphIndex = end;
      return res;
    });

    return new _GlyphString2.default(attributedString.string, glyphRuns);
  };

  GlyphGenerator.prototype.resolveGlyphIndices = function resolveGlyphIndices(string, stringIndices) {
    var glyphIndices = [];

    for (var i = 0; i < string.length; i++) {
      for (var j = 0; j < stringIndices.length; j++) {
        if (stringIndices[j] >= i) {
          glyphIndices[i] = j;
          break;
        }

        glyphIndices[i] = undefined;
      }
    }

    var lastValue = glyphIndices[glyphIndices.length - 1];
    for (var _i = glyphIndices.length - 1; _i >= 0; _i--) {
      if (glyphIndices[_i] === undefined) {
        glyphIndices[_i] = lastValue;
      } else {
        lastValue = glyphIndices[_i];
      }
    }

    lastValue = glyphIndices[0];
    for (var _i2 = 0; _i2 < glyphIndices.length; _i2++) {
      if (glyphIndices[_i2] === undefined) {
        glyphIndices[_i2] = lastValue;
      } else {
        lastValue = glyphIndices[_i2];
      }
    }

    return glyphIndices;
  };

  GlyphGenerator.prototype.resolveRuns = function resolveRuns(attributedString) {
    // Map attributes to RunStyle objects
    var r = attributedString.runs.map(function (run) {
      return new _Run2.default(run.start, run.end, new _RunStyle2.default(run.attributes));
    });

    // Resolve run ranges and additional attributes
    var runs = [];
    for (var _iterator = this.resolvers, _isArray = Array.isArray(_iterator), _i3 = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i3 >= _iterator.length) break;
        _ref = _iterator[_i3++];
      } else {
        _i3 = _iterator.next();
        if (_i3.done) break;
        _ref = _i3.value;
      }

      var resolver = _ref;

      var resolved = resolver.getRuns(attributedString.string, r);
      runs.push.apply(runs, resolved);
    }

    // Ignore resolved properties
    var styles = attributedString.runs.map(function (run) {
      var attrs = (0, _assign2.default)({}, run.attributes);
      delete attrs.font;
      delete attrs.fontDescriptor;
      return new _Run2.default(run.start, run.end, attrs);
    });

    // Flatten runs
    var resolvedRuns = (0, _flattenRuns2.default)([].concat(styles, runs));
    for (var _iterator2 = resolvedRuns, _isArray2 = Array.isArray(_iterator2), _i4 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i4 >= _iterator2.length) break;
        _ref2 = _iterator2[_i4++];
      } else {
        _i4 = _iterator2.next();
        if (_i4.done) break;
        _ref2 = _i4.value;
      }

      var run = _ref2;

      run.attributes = new _RunStyle2.default(run.attributes);
    }

    return resolvedRuns;
  };

  GlyphGenerator.prototype.resolveAttachments = function resolveAttachments(glyphRun) {
    var _glyphRun$attributes = glyphRun.attributes,
        font = _glyphRun$attributes.font,
        attachment = _glyphRun$attributes.attachment;


    if (!attachment) {
      return;
    }

    var objectReplacement = font.glyphForCodePoint(0xfffc);

    for (var i = 0; i < glyphRun.length; i++) {
      var glyph = glyphRun.glyphs[i];
      var position = glyphRun.positions[i];

      if (glyph === objectReplacement) {
        position.xAdvance = attachment.width;
      }
    }
  };

  GlyphGenerator.prototype.resolveYOffset = function resolveYOffset(glyphRun) {
    var _glyphRun$attributes2 = glyphRun.attributes,
        font = _glyphRun$attributes2.font,
        yOffset = _glyphRun$attributes2.yOffset;


    if (!yOffset) {
      return;
    }

    for (var i = 0; i < glyphRun.length; i++) {
      glyphRun.positions[i].yOffset += yOffset * font.unitsPerEm;
    }
  };

  return GlyphGenerator;
}();

exports.default = GlyphGenerator;