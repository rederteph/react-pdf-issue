'use strict';

exports.__esModule = true;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _Point = require('./Point');

var _Point2 = _interopRequireDefault(_Point);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CORNERS = ['topLeft', 'topRight', 'bottomLeft', 'bottomRight'];

/**
 * Represents a rectangle
 */

var Rect = function () {
  /** @public */
  function Rect() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    (0, _classCallCheck3.default)(this, Rect);

    /**
     * The x-coordinate of the rectangle
     * @type {number}
     */
    this.x = x;

    /**
     * The y-coordinate of the rectangle
     * @type {number}
     */
    this.y = y;

    /**
     * The width of the rectangle
     * @type {number}
     */
    this.width = width;

    /**
     * The height of the rectangle
     * @type {number}
     */
    this.height = height;
  }

  /**
   * The maximum x-coordinate in the rectangle
   * @type {number}
   */


  /**
   * Returns whether this rectangle intersects another rectangle
   * @param {Rect} rect - The rectangle to check
   * @return {boolean}
   */
  Rect.prototype.intersects = function intersects(rect) {
    return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;
  };

  /**
   * Returns whether this rectangle fully contains another rectangle
   * @param {Rect} rect - The rectangle to check
   * @return {boolean}
   */


  Rect.prototype.containsRect = function containsRect(rect) {
    return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;
  };

  /**
   * Returns whether the rectangle contains the given point
   * @param {Point} point - The point to check
   * @return {boolean}
   */


  Rect.prototype.containsPoint = function containsPoint(point) {
    return this.x <= point.x && this.y <= point.y && this.maxX >= point.x && this.maxY >= point.y;
  };

  /**
   * Returns the first corner of this rectangle (from top to bottom, left to right)
   * that is contained in the given rectangle, or null of the rectangles do not intersect.
   * @param {Rect} rect - The rectangle to check
   * @return {string}
   */


  Rect.prototype.getCornerInRect = function getCornerInRect(rect) {
    for (var _iterator = CORNERS, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var key = _ref;

      if (rect.containsPoint(this[key])) {
        return key;
      }
    }

    return null;
  };

  Rect.prototype.equals = function equals(rect) {
    return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;
  };

  Rect.prototype.pointEquals = function pointEquals(point) {
    return this.x === point.x && this.y === point.y;
  };

  Rect.prototype.sizeEquals = function sizeEquals(size) {
    return this.width === size.width && this.height === size.height;
  };

  /**
   * Returns a copy of this rectangle
   * @return {Rect}
   */


  Rect.prototype.copy = function copy() {
    return new Rect(this.x, this.y, this.width, this.height);
  };

  (0, _createClass3.default)(Rect, [{
    key: 'maxX',
    get: function get() {
      return this.x + this.width;
    }

    /**
     * The maximum y-coordinate in the rectangle
     * @type {number}
     */

  }, {
    key: 'maxY',
    get: function get() {
      return this.y + this.height;
    }

    /**
     * The area of the rectangle
     * @type {number}
     */

  }, {
    key: 'area',
    get: function get() {
      return this.width * this.height;
    }

    /**
     * The top left corner of the rectangle
     * @type {Point}
     */

  }, {
    key: 'topLeft',
    get: function get() {
      return new _Point2.default(this.x, this.y);
    }

    /**
     * The top right corner of the rectangle
     * @type {Point}
     */

  }, {
    key: 'topRight',
    get: function get() {
      return new _Point2.default(this.maxX, this.y);
    }

    /**
     * The bottom left corner of the rectangle
     * @type {Point}
     */

  }, {
    key: 'bottomLeft',
    get: function get() {
      return new _Point2.default(this.x, this.maxY);
    }

    /**
     * The bottom right corner of the rectangle
     * @type {Point}
     */

  }, {
    key: 'bottomRight',
    get: function get() {
      return new _Point2.default(this.maxX, this.maxY);
    }
  }]);
  return Rect;
}();

exports.default = Rect;