'use strict';

exports.__esModule = true;

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _iterator5 = require('babel-runtime/core-js/symbol/iterator');

var _iterator6 = _interopRequireDefault(_iterator5);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _unicodeProperties = require('@react-pdf/unicode-properties');

var _unicodeProperties2 = _interopRequireDefault(_unicodeProperties);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://www.w3.org/TR/css-text-3/#hanging-punctuation
var HANGING_PUNCTUATION_START_CATEGORIES = new _set2.default(['Ps', 'Pi', 'Pf']);
var HANGING_PUNCTUATION_END_CATEGORIES = new _set2.default(['Pe', 'Pi', 'Pf']);
var HANGING_PUNCTUATION_END_CODEPOINTS = new _set2.default([0x002c, // COMMA
0x002e, // FULL STOP
0x060c, // ARABIC COMMA
0x06d4, // ARABIC FULL STOP
0x3001, // IDEOGRAPHIC COMMA
0x3002, // IDEOGRAPHIC FULL STOP
0xff0c, // FULLWIDTH COMMA
0xff0e, // FULLWIDTH FULL STOP
0xfe50, // SMALL COMMA
0xfe51, // SMALL IDEOGRAPHIC COMMA
0xfe52, // SMALL FULL STOP
0xff61, // HALFWIDTH IDEOGRAPHIC FULL STOP
0xff64, // HALFWIDTH IDEOGRAPHIC COMMA
0x002d // HYPHEN
]);

var GlyphString = function () {
  function GlyphString(string, glyphRuns, start, end) {
    (0, _classCallCheck3.default)(this, GlyphString);

    this.string = string;
    this._glyphRuns = glyphRuns;
    this.start = start || 0;
    this._end = end;
    this._glyphRunsCache = null;
    this._glyphRunsCacheEnd = null;
  }

  GlyphString.prototype.slice = function slice(start, end) {
    var stringStart = this.stringIndexForGlyphIndex(start);
    var stringEnd = this.stringIndexForGlyphIndex(end);

    return new GlyphString(this.string.slice(stringStart, stringEnd), this._glyphRuns, start + this.start, end + this.start);
  };

  GlyphString.prototype.runIndexAtGlyphIndex = function runIndexAtGlyphIndex(index) {
    index += this.start;
    var count = 0;

    for (var i = 0; i < this._glyphRuns.length; i++) {
      var run = this._glyphRuns[i];

      if (count <= index && index < count + run.glyphs.length) {
        return i;
      }

      count += run.glyphs.length;
    }

    return this._glyphRuns.length - 1;
  };

  GlyphString.prototype.runAtGlyphIndex = function runAtGlyphIndex(index) {
    index += this.start;

    for (var i = 0; i < this.glyphRuns.length; i++) {
      var run = this.glyphRuns[i];

      if (run.start <= index && run.end > index) {
        return run;
      }
    }

    return this.glyphRuns[this.glyphRuns.length - 1];
  };

  GlyphString.prototype.runIndexAtStringIndex = function runIndexAtStringIndex(index) {
    var offset = 0;

    for (var i = 0; i < this.glyphRuns.length; i++) {
      var run = this.glyphRuns[i];

      if (offset + run.stringStart <= index && offset + run.stringEnd >= index) {
        return i;
      }

      offset += run.stringEnd;
    }

    return this._glyphRuns.length - 1;
  };

  GlyphString.prototype.runAtStringIndex = function runAtStringIndex(index) {
    return this.glyphRuns[this.runIndexAtStringIndex(index)];
  };

  GlyphString.prototype.glyphAtIndex = function glyphAtIndex(index) {
    var run = this.runAtGlyphIndex(index);
    return run.glyphs[this.start + index - run.start];
  };

  GlyphString.prototype.positionAtIndex = function positionAtIndex(index) {
    var run = void 0;
    var count = 0;

    for (var i = 0; i < this.glyphRuns.length; i++) {
      run = this.glyphRuns[i];

      if (count <= index && index < count + run.positions.length) {
        return run.positions[index - count];
      }

      count += run.positions.length;
    }

    return run.positions[run.positions.length - 1];
  };

  GlyphString.prototype.getGlyphWidth = function getGlyphWidth(index) {
    return this.positionAtIndex(index).xAdvance;
  };

  GlyphString.prototype.glyphIndexAtOffset = function glyphIndexAtOffset(width) {
    var offset = 0;
    var index = 0;

    for (var _iterator = this.glyphRuns, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var run = _ref;

      if (offset + run.advanceWidth > width) {
        for (var _iterator2 = run.positions, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {
          var _ref2;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref2 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref2 = _i2.value;
          }

          var position = _ref2;

          var w = position.xAdvance;
          if (offset + w > width) {
            return index;
          }

          offset += w;
          index++;
        }
      } else {
        offset += run.advanceWidth;
        index += run.glyphs.length;
      }
    }

    return index;
  };

  GlyphString.prototype.stringIndexForGlyphIndex = function stringIndexForGlyphIndex(index) {
    var run = void 0;
    var count = 0;
    var offset = 0;

    for (var i = 0; i < this.glyphRuns.length; i++) {
      run = this.glyphRuns[i];

      if (offset <= index && offset + run.length > index) {
        return count + run.stringIndices[index + this.start - run.start];
      }

      offset += run.length;
      count += run.glyphIndices.length;
    }

    return count;
  };

  GlyphString.prototype.glyphIndexForStringIndex = function glyphIndexForStringIndex(index) {
    var run = void 0;
    var count = 0;
    var offset = 0;

    for (var i = 0; i < this.glyphRuns.length; i++) {
      run = this.glyphRuns[i];

      if (offset <= index && index < offset + run.stringEnd + 1) {
        return count + run.glyphIndices[index - offset];
      }

      count += run.glyphs.length;
      offset += run.stringEnd + 1;
    }

    return offset;
  };

  GlyphString.prototype.codePointAtGlyphIndex = function codePointAtGlyphIndex(glyphIndex) {
    return this.string.codePointAt(this.stringIndexForGlyphIndex(glyphIndex));
  };

  GlyphString.prototype.charAtGlyphIndex = function charAtGlyphIndex(glyphIndex) {
    return this.string.charAt(this.stringIndexForGlyphIndex(glyphIndex));
  };

  GlyphString.prototype.offsetAtGlyphIndex = function offsetAtGlyphIndex(glyphIndex) {
    var offset = 0;
    var count = glyphIndex;

    for (var _iterator3 = this.glyphRuns, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var run = _ref3;

      for (var i = 0; i < run.glyphs.length; i++) {
        if (count === 0) {
          return offset;
        }

        offset += run.positions[i].xAdvance;
        count -= 1;
      }
    }

    return offset;
  };

  GlyphString.prototype.indexOf = function indexOf(string) {
    var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    var stringIndex = this.stringIndexForGlyphIndex(index);
    var nextIndex = this.string.indexOf(string, stringIndex);

    if (nextIndex === -1) {
      return -1;
    }

    return this.glyphIndexForStringIndex(nextIndex);
  };

  GlyphString.prototype.getUnicodeCategory = function getUnicodeCategory(index) {
    var codePoint = this.codePointAtGlyphIndex(index);
    return codePoint ? _unicodeProperties2.default.getCategory(codePoint) : null;
  };

  GlyphString.prototype.isWhiteSpace = function isWhiteSpace(index) {
    var codePoint = this.codePointAtGlyphIndex(index);
    return codePoint ? _unicodeProperties2.default.isWhiteSpace(codePoint) : false;
  };

  GlyphString.prototype.isHangingPunctuationStart = function isHangingPunctuationStart(index) {
    return HANGING_PUNCTUATION_START_CATEGORIES.has(this.getUnicodeCategory(index));
  };

  GlyphString.prototype.isHangingPunctuationEnd = function isHangingPunctuationEnd(index) {
    return HANGING_PUNCTUATION_END_CATEGORIES.has(this.getUnicodeCategory(index)) || HANGING_PUNCTUATION_END_CODEPOINTS.has(this.codePointAtGlyphIndex(index));
  };

  GlyphString.prototype.insertGlyph = function insertGlyph(index, codePoint) {
    var runIndex = this.runIndexAtGlyphIndex(index);
    var run = this._glyphRuns[runIndex];
    var _run$attributes = run.attributes,
        font = _run$attributes.font,
        fontSize = _run$attributes.fontSize;

    var glyph = run.attributes.font.glyphForCodePoint(codePoint);
    var scale = fontSize / font.unitsPerEm;
    var glyphIndex = this.start + index - run.start;

    if (this._end) {
      this._end += 1;
    }

    run.glyphs.splice(glyphIndex, 0, glyph);
    run.stringIndices.splice(glyphIndex, 0, run.stringIndices[glyphIndex]);

    for (var i = 0; i < run.glyphIndices.length; i++) {
      if (run.glyphIndices[i] >= glyphIndex) {
        run.glyphIndices[i] += 1;
      }
    }

    run.positions.splice(glyphIndex, 0, {
      xAdvance: glyph.advanceWidth * scale,
      yAdvance: 0,
      xOffset: 0,
      yOffset: run.attributes.yOffset * font.unitsPerEm
    });

    run.end += 1;

    for (var _i4 = runIndex + 1; _i4 < this._glyphRuns.length; _i4++) {
      this._glyphRuns[_i4].start += 1;
      this._glyphRuns[_i4].end += 1;
    }

    this._glyphRunsCache = null;
  };

  GlyphString.prototype.deleteGlyph = function deleteGlyph(index) {
    if (index < 0 || index >= this.length) {
      return;
    }

    var runIndex = this.runIndexAtGlyphIndex(index);
    var run = this._glyphRuns[runIndex];
    var glyphIndex = this.start + index - run.start;

    run.glyphs.splice(glyphIndex, 1);
    run.positions.splice(glyphIndex, 1);
    run.stringIndices.splice(glyphIndex, 1);

    for (var i = 0; i < run.glyphIndices.length; i++) {
      if (run.glyphIndices[i] >= glyphIndex) {
        run.glyphIndices[i] -= 1;
      }
    }

    run.end--;

    for (var _i5 = runIndex + 1; _i5 < this._glyphRuns.length; _i5++) {
      this._glyphRuns[_i5].start--;
      this._glyphRuns[_i5].end--;
    }

    this._glyphRunsCache = null;
  };

  GlyphString.prototype[_iterator6.default] = /*#__PURE__*/_regenerator2.default.mark(function _callee() {
    var x, _iterator4, _isArray4, _i6, _ref4, run, i;

    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            x = 0;
            _iterator4 = this.glyphRuns, _isArray4 = Array.isArray(_iterator4), _i6 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);

          case 2:
            if (!_isArray4) {
              _context.next = 8;
              break;
            }

            if (!(_i6 >= _iterator4.length)) {
              _context.next = 5;
              break;
            }

            return _context.abrupt('break', 23);

          case 5:
            _ref4 = _iterator4[_i6++];
            _context.next = 12;
            break;

          case 8:
            _i6 = _iterator4.next();

            if (!_i6.done) {
              _context.next = 11;
              break;
            }

            return _context.abrupt('break', 23);

          case 11:
            _ref4 = _i6.value;

          case 12:
            run = _ref4;
            i = 0;

          case 14:
            if (!(i < run.glyphs.length)) {
              _context.next = 21;
              break;
            }

            _context.next = 17;
            return {
              glyph: run.glyphs[i],
              position: run.positions[i],
              run: run,
              x: x,
              index: run.start + i
            };

          case 17:

            x += run.positions[i].xAdvance;

          case 18:
            i++;
            _context.next = 14;
            break;

          case 21:
            _context.next = 2;
            break;

          case 23:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  });
  (0, _createClass3.default)(GlyphString, [{
    key: 'end',
    get: function get() {
      if (this._glyphRuns.length === 0) {
        return 0;
      }

      var glyphEnd = this._glyphRuns[this._glyphRuns.length - 1].end;

      if (this._end) {
        return Math.min(this._end, glyphEnd);
      }

      return this._glyphRuns.length > 0 ? glyphEnd : 0;
    }
  }, {
    key: 'length',
    get: function get() {
      return this.end - this.start;
    }
  }, {
    key: 'advanceWidth',
    get: function get() {
      return this.glyphRuns.reduce(function (acc, run) {
        return acc + run.advanceWidth;
      }, 0);
    }
  }, {
    key: 'height',
    get: function get() {
      return this.glyphRuns.reduce(function (acc, run) {
        return Math.max(acc, run.height);
      }, 0);
    }
  }, {
    key: 'ascent',
    get: function get() {
      return this.glyphRuns.reduce(function (acc, run) {
        return Math.max(acc, run.ascent);
      }, 0);
    }
  }, {
    key: 'descent',
    get: function get() {
      return this.glyphRuns.reduce(function (acc, run) {
        return Math.min(acc, run.descent);
      }, 0);
    }
  }, {
    key: 'glyphRuns',
    get: function get() {
      if (this._glyphRunsCache && this._glyphRunsCacheEnd === this.end) {
        return this._glyphRunsCache;
      }

      if (this._glyphRuns.length === 0) {
        this._glyphRunsCache = [];
        this._glyphRunsCacheEnd = this.end;
        return [];
      }

      var startRunIndex = this.runIndexAtGlyphIndex(0);
      var endRunIndex = this.runIndexAtGlyphIndex(this.length);
      var startRun = this._glyphRuns[startRunIndex];
      var endRun = this._glyphRuns[endRunIndex];
      var runs = [];

      runs.push(startRun.slice(this.start - startRun.start, this.end - startRun.start));

      if (endRunIndex !== startRunIndex) {
        runs.push.apply(runs, this._glyphRuns.slice(startRunIndex + 1, endRunIndex));

        if (this.end - endRun.start !== 0) {
          runs.push(endRun.slice(0, this.end - endRun.start));
        }
      }

      this._glyphRunsCache = runs;
      this._glyphRunsCacheEnd = this.end;
      return runs;
    }
  }]);
  return GlyphString;
}();

exports.default = GlyphString;