'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

// Default presence ahead function. Used when node does not provides one.
var defaultPresenceAhead = function defaultPresenceAhead(element) {
  return function (height) {
    return Math.min(element.height, height);
  };
};

// Calculates the presence ahead or an array of nodes, given the available height.
var getPresenceAhead = function getPresenceAhead(elements, height) {
  var result = 0;

  for (var i = 0; i < elements.length; i++) {
    var element = elements[i];
    var isElementInside = height > element.top;
    var presenceAhead = element.presenceAhead || defaultPresenceAhead(element);

    if (element && isElementInside) {
      result += presenceAhead(height - element.top);
    }
  }

  return result;
};

// Clone element recursively including children
var cloneRecursively = function cloneRecursively(node) {
  var clone = node.clone();

  if (node.children && node.children.length > 0) {
    node.children.forEach(function (child) {
      return clone.appendChild(cloneRecursively(child));
    });
  }

  return clone;
};

// Wrap nodes tree in fixed height page, and returns exceedings separately.
var wrap = function wrap(elements, height, pageNumber) {
  var nextPageElements = [];
  var elementsToBeRemoved = [];

  for (var i = 0; i < elements.length; i++) {
    var element = elements[i];

    if (element.nodeWillWrap) element.nodeWillWrap({ pageNumber: pageNumber });

    var futureElements = elements.slice(i + 1);
    var isElementOutside = height <= element.top;
    var elementShouldSplit = height < element.top + element.height;
    var elementShouldBreak = element.break || !element.wrap && elementShouldSplit;

    // If element is fixed, we add it both to the current page
    // and to all future pages to come.
    if (element.fixed) {
      nextPageElements.push(cloneRecursively(element));
      continue;
    }

    // If current element is outside wrapping zone, we ignore it completely.
    // Just substract page height so next time will be upper in the page's layout.
    if (isElementOutside) {
      nextPageElements.push(cloneRecursively(element));
      elementsToBeRemoved.push(element);
      continue;
    }

    // Checks if element has more than the minimun presence ahead on that page.
    // If not, we break the page in this element.
    if (element.minPresenceAhead) {
      var presenceAhead = getPresenceAhead(futureElements, height);
      if (presenceAhead < element.minPresenceAhead) elementShouldBreak = true;
    }

    // Element can break based on many conditions: if has the break flag,
    // if has the wrap flag as false and should be splitted or didn't have enough
    // presence ahead. Either way, the element get's relocated on the next page,
    // as well as all other next elements.
    if (elementShouldBreak) {
      var clone = cloneRecursively(element);
      var newFutureElements = futureElements.map(function (element) {
        return cloneRecursively(element);
      });
      var nonFixedElements = futureElements.filter(function (element) {
        return !element.fixed;
      });

      clone.top = 0;
      clone.break = false;

      nextPageElements.push.apply(nextPageElements, [clone].concat(newFutureElements));
      elementsToBeRemoved.push.apply(elementsToBeRemoved, [element].concat(nonFixedElements));
      break;
    }

    // Element is between to pages and needs to be splitted.
    // We clone the original one adjusting his dimensions, and send the
    // remaining section to be rendered on next page
    if (elementShouldSplit) {
      var _ret = function () {
        var clone = element.clone();
        var remainingHeight = height - element.top;

        if (element.children && element.children.length > 0) {
          var wrappedChildren = wrap(element.children, remainingHeight);
          wrappedChildren.forEach(function (child) {
            return clone.appendChild(child);
          });
        }

        element.onNodeSplit(remainingHeight, clone);
        nextPageElements.push(clone);

        return "continue";
      }();

      if (_ret === "continue") continue;
    }
  }

  // Remove elements that didn't fit inside page
  // We do this here to not interfer with upper elements iteration
  elementsToBeRemoved.forEach(function (element) {
    return element.remove();
  });

  return nextPageElements;
};

// Wrap nodes tree in equal sized subpages
var wrapPages = function wrapPages(nodes, height, pageIndex) {
  var nextPage = wrap(nodes, height, pageIndex++)[0];

  if (!nextPage || nextPage.isEmpty()) return nodes;

  var hasOnlyFixedChilds = nextPage.children.length > 0 && nextPage.children.every(function (c) {
    return c.fixed;
  });

  if (hasOnlyFixedChilds) return nodes;

  return [].concat(nodes, wrapPages([nextPage], height, pageIndex));
};

var wrapPage = function wrapPage(page, height) {
  var pageIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  if (!page) return [];
  return wrapPages([cloneRecursively(page)], height, pageIndex);
};

exports.wrap = wrap;
exports['default'] = wrapPage;
