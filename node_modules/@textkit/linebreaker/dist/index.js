'use strict';

exports.__esModule = true;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _linebreak = require('linebreak');

var _linebreak2 = _interopRequireDefault(_linebreak);

var _hypher = require('hypher');

var _hypher2 = _interopRequireDefault(_hypher);

var _hyphenation = require('hyphenation.en-us');

var _hyphenation2 = _interopRequireDefault(_hyphenation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hyphenator = new _hypher2.default(_hyphenation2.default);
var HYPHEN = 0x002d;
var SHRINK_FACTOR = 0.04;

/**
 * A LineBreaker is used by the Typesetter to perform
 * Unicode line breaking and hyphenation.
 */

exports.default = function () {
  return function () {
    return function () {
      function LineBreaker() {
        (0, _classCallCheck3.default)(this, LineBreaker);
      }

      LineBreaker.prototype.suggestLineBreak = function suggestLineBreak(glyphString, width, paragraphStyle) {
        var hyphenationFactor = paragraphStyle.hyphenationFactor || 0;
        var glyphIndex = glyphString.glyphIndexAtOffset(width);

        if (glyphIndex === -1) return null;

        if (glyphIndex === glyphString.length) {
          return { position: glyphString.length, required: true };
        }

        var stringIndex = glyphString.stringIndexForGlyphIndex(glyphIndex);
        var bk = this.findBreakPreceeding(glyphString.string, stringIndex);

        if (bk) {
          var breakIndex = glyphString.glyphIndexForStringIndex(bk.position);

          if (bk.next != null && this.shouldHyphenate(glyphString, breakIndex, width, hyphenationFactor)) {
            var lineWidth = glyphString.offsetAtGlyphIndex(glyphIndex);
            var shrunk = lineWidth + lineWidth * SHRINK_FACTOR;

            var shrunkIndex = glyphString.glyphIndexAtOffset(shrunk);
            stringIndex = Math.min(bk.next, glyphString.stringIndexForGlyphIndex(shrunkIndex));

            var point = this.findHyphenationPoint(glyphString.string.slice(bk.position, bk.next), stringIndex - bk.position);

            if (point > 0) {
              bk.position += point;
              breakIndex = glyphString.glyphIndexForStringIndex(bk.position);

              if (bk.position < bk.next) {
                glyphString.insertGlyph(breakIndex++, HYPHEN);
              }
            }
          }

          bk.position = breakIndex;
        }

        return bk;
      };

      LineBreaker.prototype.findBreakPreceeding = function findBreakPreceeding(string, index) {
        var breaker = new _linebreak2.default(string);
        var last = null;
        var bk = null;

        while (bk = breaker.nextBreak()) {
          // console.log(bk);
          if (bk.position > index) {
            if (last) {
              last.next = bk.position;
            }

            return last;
          }

          if (bk.required) {
            return bk;
          }

          last = bk;
        }

        return null;
      };

      LineBreaker.prototype.shouldHyphenate = function shouldHyphenate(glyphString, glyphIndex, width, hyphenationFactor) {
        var lineWidth = glyphString.offsetAtGlyphIndex(glyphIndex);
        return lineWidth / width < hyphenationFactor;
      };

      LineBreaker.prototype.findHyphenationPoint = function findHyphenationPoint(string, index) {
        var parts = hyphenator.hyphenate(string);
        var count = 0;

        for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var part = _ref;

          if (count + part.length > index) {
            break;
          }

          count += part.length;
        }

        return count;
      };

      return LineBreaker;
    }();
  };
};